<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入javascript之作用域]]></title>
    <url>%2F2018%2F04%2F20%2F%E6%B7%B1%E5%85%A5JavaScript%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[一，作用域包括静态作用域和动态作用域，静态作用域也叫词法作用域，JavaScript采用的是静态作用域。 JavaScript中作用域是指可访问变量，对象，函数的集合，也就是调用它们能生效的代码区块。在JavaScript中没有块级作用域，只有全局作用域和函数作用域，可以模仿块级作用域，下面会讲到。 全局，函数作用域看个简单的例子12345678910111213var a = 10 function f1()&#123; var b = c = 20; console.log(a); //10 console.log(c); //20 function f2() &#123; console.log(b); //20 &#125;f2(); &#125; f1(); console.log(a); //10 console.log(c); //20 console.log(b); //error var b = c = 20 是指 var b = c; c = 20在f1函数中c没使用var声明为全局变量，b为局部变量，绑定在f1函数下，外部访问不到。 模仿块级作用域没有块级作用域，但是有if()，for()等块语句，在块语句内部定义的变量会保留在它们已经存在的作用域内，举个栗子：12345if(true) &#123; var word = 'hello'; console.log(word); //hello &#125; console.log(word); //hello f()语句存在全局作用域下，所以内部定义的变量存在于全局作用域中，无论在哪都可以访问。 123456789function add(num) &#123; if(num &gt; 10) &#123; var num = 10; console.log(num); //10 &#125; console.log(num); //10 &#125; add(11); console.log(num); //Uncaught ReferenceError: num is not defined 此时if()在add函数中，内部定义的变量存在于add函数的作用域中，只有在函数和块语句中才可以访问到，外部无法访问。 使用自执行的匿名函数包裹块语句构建块作用域，也叫私有作用域1234567function add(num) &#123; for(var i = 0; i &lt; num; i++) &#123; console.log(i); //0,1,2,3,4,5,6,7,8,9 &#125; console.log(i); //10 &#125; add(10); 将代码改为：123456789function add(num) &#123; (function () &#123; for(var i = 0; i &lt; num; i++) &#123; console.log(i); //0,1,2,3,4,5,6,7,8,9 &#125; &#125;)() console.log(i); //Uncaught ReferenceError: i is not defined &#125; add(10); 此时变量i只能在for()循环中访问到，在add函数和外部都无法访问，并且在匿名函数中定义的任何变量都会在执行结束时被销毁，所以变量i只能在for()循环中使用。 在ES6中新增了块级作用域，let const声明的变量在块语句中声明时，外部无法访问。 对作用域有明确的理解对于后面学习执行上下文会有很大帮助。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入javascript之原型和原型链]]></title>
    <url>%2F2018%2F04%2F19%2F%E6%B7%B1%E5%85%A5javascript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型和原型链是js中的难点也是重点，明白了原型和原型链会让我们在后面不管是学习还是工作都会更加高效，并且原型和原型链会是面试中必不可少的话题。看完此篇文章一定会让你对原型，原型链有深刻全面的了解。 一，函数对象 所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型） 所有函数拥有prototype属性（显式原型）（仅限函数） 原型对象：拥有prototype属性的对象，在定义函数时就被创建 二，构造函数看段代码1234567891011121314151617//创建构造函数 function Word(words)&#123; this.words = words; &#125; Word.prototype = &#123; alert()&#123; alert(this.words); &#125; &#125; //创建实例 var w = new Word("hello world"); w.print = function()&#123; console.log(this.words); console.log(this); //Person对象 &#125; w.print(); //hello world w.alert(); //hello world print()方法是w实例本身具有的方法，所以w.print()打印hello world；alert()不属于w实例的方法，属于构造函数的方法，w.alert()也会打印hello world，因为实例继承构造函数的方法。 实例w的隐式原型指向它构造函数的显式原型 1w.__proto__ === Word.prototype 当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的__proto__属性中调用查找，也就是它构造函数的prototype中调用查找。所以很好理解实例继承构造函数的方法和属性： w本身没有alert()方法，所以会去Word()的显式原型中调用alert()，即实例继承构造函数的方法。 三，原型和原型链12345678Function.prototype.a = "a"; Object.prototype.b = "b"; function Person()&#123;&#125; console.log(Person); //function Person() let p = new Person(); console.log(p); //Person &#123;&#125; 对象 console.log(p.a); //undefined console.log(p.b); //b 想一想p.a打印结果为undefined，p.b结果为b p是Person()的实例，是一个Person对象，它拥有一个属性值__proto__，并且__proto__是一个对象，包含两个属性值constructor和__proto__。 12console.log(p.__proto__.constructor); //function Person()&#123;&#125; console.log(p.__proto__.__proto__); //对象&#123;&#125;，拥有很多属性值 我们会发现p.__proto__.constructor返回的结果为构造函数本身，p.__proto__.__proto__有很多参数。 我们调用constructor属性，p.__proto__.__proto__.constructor得到拥有多个参数的Object()函数，Person.prototype的隐式原型的constructor指向Object()，即Person.prototype.__proto__.constructor == Object()。 从p.__proto__.constructor返回的结果为构造函数本身得到Person.prototype.constructor == Person()所以p.__proto__.__proto__== Object.prototype 。 所以p.b打印结果为b，p没有b属性，会一直通过__proto__向上查找，最后当查找到Object.prototype时找到，最后打印出b，向上查找过程中，得到的是Object.prototype，而不是Function.prototype，找不到a属性，所以结果为undefined，这就是原型链，通过__proto__向上进行查找，最终到null结束。 12console.log(p.__proto__.__proto__.__proto__); //null console.log(Object.prototype.__proto__); //null 大家理解刚才的过程，相信下面这些应该也都明白 12345678//Function function Function()&#123;&#125; console.log(Function); //Function() console.log(Function.prototype.constructor); //Function() console.log(Function.prototype.__proto__); //Object.prototype console.log(Function.prototype.__proto__.__proto__); //NULL console.log(Function.prototype.__proto__.constructor); //Object() console.log(Function.prototype.__proto__ === Object.prototype); //true 四，总结1. 查找属性，如果本身没有，则会去__proto__中查找，也就是构造函数的显式原型中查找，如果构造函数中也没有该属性，因为构造函数也是对象，也有__proto__，那么会去它的显式原型中查找，一直到null，如果没有则返回undefined。 2. p.__proto__.constructor == function Person(){} 3. p.___proto__.__proto__== Object.prototype 4. p.___proto__.__proto__.__proto__== Object.prototype.__proto__ == null 5. 通过__proto__形成原型链而非protrotype 最后附上一张图，大家阅读完之后，看图应该可以很容易理解]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
</search>
