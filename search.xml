<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nodejs搭建一个简单服务器]]></title>
    <url>%2Fnode-http-server.html</url>
    <content type="text"><![CDATA[nodejs文档 创建一个简单的http服务器： 加载http模块 创建http服务对象 监听用户请求事件 设置监听端口 新建一个demo.js文件 加载http模块 1const http = require('http'); 创建http服务对象 http.createServer()方法创建http服务对象 1const server = http.createServer(); 监听用户请求事件并设置监听端口 response.write(chunk[, encoding][, callback])通过res.write()方法发送响应体，可多次调用有三个参数，第一个参数必传，必须为字符串或buffer,不能为数组，对象等第二，三个参数选传，分别为编码格式，默认为utf8，另外是回调 必须调用res.end()方法告诉服务器响应完毕，可结束响应12345678server.on('request', (req, res) =&gt; &#123; // 设置请求头 res.setHeader('Content-Type', 'text/plain; charset=utf-8'); res.write('hello node'); res.end();&#125;).listen(8888, () =&gt; &#123; console.log('服务已经启动');&#125;) 进一步优化代码：12345678const http = require('http');http.createServer((req, res) =&gt; &#123; // 设置请求头 res.setHeader('Content-Type', 'text/plain; charset=utf-8'); res.end('hello node');&#125;).listen(8888, () =&gt; &#123; console.log('服务已经启动');&#125;) 到此一个最简单的http服务器就搭建完成，命令行运行node demo，在浏览器中输入localhost:8888就可以看到hello node。]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入网址到页面呈现过程]]></title>
    <url>%2Furl-ip.html</url>
    <content type="text"><![CDATA[面试中经常会问的一个问题，先简述，后面会仔细描述每一步骤 输入网址，敲回车 浏览器通过输入的URL，构建HTTP请求报文 浏览器发起DNS解析，将域名转换为IP地址 浏览器将请求报文发送给服务器 服务器接收到请求报文并进行解析 服务器处理用户请求，将处理结果封装成HTTP响应报文 服务器将响应报文发送给浏览器 浏览器接受服务器发送的HTTP响应报文，并解析 浏览器渲染引擎解析HTML生成DOM树，CSS规则树，生成渲染树，进行layout，最后绘制 解析HTML时遇到新的资源需要再次发起请求 最终浏览器呈现页面]]></content>
      <categories>
        <category>JavaScript</category>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atom使用小技巧]]></title>
    <url>%2Fatom-tips.html</url>
    <content type="text"><![CDATA[vscode内存泄漏的问题，不得已放弃，转而使用atom，用了之后才发现atom真的太好用了下载地址：atom 在这说一下atom的一些小玩意 tips 安装插件点击 File – Settings – Install 搜索想要安装的插件进行安装即可 自定义代码段相比于vscode，我更喜欢atom自定义代码段风格，更加方便 vscode自定义代码段 atom自定义代码段，以vue为例我们在安装vue插件时，点击插件settings，我们会看到Scope 点击 File – Snippets 将text.html.vue复制进来 text.html.vue前面需要加上一个小点 prefix 代表我们自定义代码段的关键词body 代表我们自定义的代码段，当有多行时需要前后各三个单引号进行包裹 &#39;&#39;&#39; 自定义编辑器风格点击 File – Stylesheetatom很有趣的一点是整个编辑器是一个HTML，我们可以通过css来改变其样式windows系统通过 ctrl + shift + I 打开控制台 这样我们就可以通过控制台找到找到类名来自定义样式了 atom这三个小技巧还是挺不错的，以后发现更多继续补充]]></content>
      <categories>
        <category>atom</category>
      </categories>
      <tags>
        <tag>atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发小总结]]></title>
    <url>%2Flittle-tips.html</url>
    <content type="text"><![CDATA[通过js动态添加的dom元素无法直接绑定事件，需要通过 123$('#父级节点').on('click', '绑定事件元素', function() &#123;&#125;) $(this)无法在ajax中直接使用，解决：将$(this)赋值给一变量 12345678910$('#button').on('click', function() &#123; var _this = $(this); $.ajax(&#123; type: 'get', url: '........', data: &#123; userId: _this.attr('id'); &#125; &#125;)&#125;) 通过使用.one()方法使事件只触发一次 使用eslint时对于使用了new关键字的代码需要加上 /* eslint-disable no-new */ 12345678/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) swiper3和swiper4用法上稍有不同 12345678910swiperOption: &#123; // Swiper3使用 // pagination: '.swiper-pagination' // Swiper4 pagination: &#123; el: '.swiper-pagination' &#125;, loop: true&#125;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS导出Excel文件]]></title>
    <url>%2Fjs-export-excel.html</url>
    <content type="text"><![CDATA[需求： datatable表格，每一行带有checkbox，勾选checkbox导出当前行所有数据，全选则导出所有选中行的数据 1&lt;a class="download" download="用户列表"&gt;导出&lt;/a&gt; 12345678910111213141516171819202122232425262728293031323334353637383940function exportFile() &#123; var dataArr = [];//定义数组用来保存所勾选的列表当前行数据 // 定义表头 var str = '&lt;tr&gt; &lt;th&gt;样本名称&lt;/th&gt; &lt;th&gt;问卷编码&lt;/th&gt; &lt;th&gt;提交时间&lt;/th&gt; &lt;/tr&gt;' // 遍历列表中所购选中的行 $('table').find('tr.hover-bg').each(function() &#123; var Data = new Object(); Data.AreaName = $(this).find('td:eq(1)').html(); Data.DataID= $(this).find('td:eq(2)').html(); Data.EntryTime= $(this).find('td:eq(3)').html(); dataArr.push(Data); &#125;) if($('table').find('tr').hasClass('hover-bg')) &#123; //循环遍历，每行加入tr标签，每个单元格加td标签 for (let i = 0; i &lt; dataArr.length; i++) &#123; str += '&lt;tr&gt;'; for (let item in dataArr[i]) &#123; //增加\t为了不让表格显示科学计数法或者其他格式 str += `&lt;td&gt;$&#123; dataArr[i][item] + '\t'&#125;&lt;/td&gt;`; &#125; str += '&lt;/tr&gt;'; &#125; var template = `&lt;html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40"&gt; &lt;head&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;&lt;x:ExcelWorkbook&gt;&lt;x:ExcelWorksheets&gt;&lt;x:ExcelWorksheet&gt; &lt;x:Name&gt;'录入列表.xls'&lt;/x:Name&gt; &lt;x:WorksheetOptions&gt;&lt;x:DisplayGridlines/&gt;&lt;/x:WorksheetOptions&gt;&lt;/x:ExcelWorksheet&gt; &lt;/x:ExcelWorksheets&gt;&lt;/x:ExcelWorkbook&gt;&lt;/xml&gt;&lt;![endif]--&gt; &lt;/head&gt;&lt;body&gt;&lt;table&gt;$&#123;str&#125;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;`; // 实例化一个Blob对象，其构造函数的第一个参数是包含文件内容的数组，第二个参数是包含文件类型属性的对象 var blob = new Blob([template], &#123;type: "application/vnd.ms-excel"&#125;); $('.download').attr('href', URL.createObjectURL(blob)); &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dataTables--ajax 分页基本使用]]></title>
    <url>%2FdataTables-ajax.html</url>
    <content type="text"><![CDATA[dataTables是一款很强大很好用的前端table 分页插件，地址：dataTables 如何使用大家可以去官网看看教程，此处总结下dataTables结合ajax需要注意的点 一，开始使用JavaScript代码12345678910111213$(document).ready(function() &#123; $('#example').DataTable( &#123; "ajax": "数据url", "columns": [ &#123; "data": "name" &#125;, &#123; "data": "position" &#125;, &#123; "data": "office" &#125;, &#123; "data": "extn" &#125;, &#123; "data": "start_date" &#125;, &#123; "data": "salary" &#125; ] &#125; );&#125; ); json数据12345678910111213141516171819202122&#123; "data": [ &#123; "id": "1", "name": "Tiger Nixon", "position": "System Architect", "salary": "$320,800", "start_date": "2011/04/25", "office": "Edinburgh", "extn": "5421" &#125;, &#123; "id": "2", "name": "Garrett Winters", "position": "Accountant", "salary": "$170,750", "start_date": "2011/07/25", "office": "Tokyo", "extn": "8422" &#125;, ]&#125; 数据格式必须一致，data作为key，值为数组对象，获取对象属性值能够直接使用data.属性名来调用获取。 如果不能使用data.属性名来直接调用获取值则需要使用dataSrc来动态指向数据源。 JavaScript代码1234567891011121314$(document).ready(function() &#123; $('#example').DataTable( &#123; "ajax": "数据url", "dataSrc": "data.records", "columns": [ &#123; "data": "name" &#125;, &#123; "data": "position" &#125;, &#123; "data": "office" &#125;, &#123; "data": "extn" &#125;, &#123; "data": "start_date" &#125;, &#123; "data": "salary" &#125; ] &#125; );&#125; ); json数据12345678910111213141516171819202122"data": &#123; "records": [ &#123; "id": "1", "name": "Tiger Nixon", "position": "System Architect", "salary": "$320,800", "start_date": "2011/04/25", "office": "Edinburgh", "extn": "5421" &#125;, &#123; "id": "2", "name": "Garrett Winters", "position": "Accountant", "salary": "$170,750", "start_date": "2011/07/25", "office": "Tokyo", "extn": "8422" &#125;, ]&#125; 二，服务器处理(Server-side processing)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980"processing": true,"serverSide": true,ajax(data, callback, settings) &#123; console.log(data); //封装请求参数 var param = &#123;&#125;; param.pageSize = data.length; //页面显示记录条数，在页面显示每页显示多少项的时候 param.pageIndex = data.start + 1; //开始的记录序号 console.log(param); $.ajax(&#123; type: 'get', url: 'http://192.168:8766/User/list', cache: false, //禁用缓存 data: param, dataType: 'json', success: function(res) &#123; setTimeout( function () &#123; var out = &#123;&#125;; out.draw = data.draw; out.recordsTotal = res.data.count; out.recordsFiltered = res.data.count; out.data = res.data.records; callback( out ); &#125;, 50 ); &#125;, error() &#123; alert('error'); &#125; &#125;)&#125;,"bLengthChange": false, //关闭选择显示条数"bSort": false, //不能排序"iDisplayLength": 10,"pagingType": "full_numbers","language": &#123; "bProcessing": "正在加载中......", "sZeroRecords": "没有检索到数据", "info": "显示 _START_ 至 _END_ 条记录，共 _TOTAL_ 条记录", "sInfoFiltered": "数据表中共为 _MAX_ 条记录", "oPaginate" : &#123; "sFirst" : "首页", "sPrevious" : "上一页", "sNext" : "下一页", "sLast" : "末页" &#125;,&#125;,"columns": [ &#123; data: 'UserId', render(data, type, full, meta) &#123; return ` &lt;input type="checkbox" class="checkchild" value="$&#123;data&#125;" /&gt; &lt;img class="check-img" src="../assets/img/backstage_icon_cheakbox_default.png" alt=""&gt; ` &#125; &#125;, &#123;data : "Account"&#125;, &#123;data : "RealName"&#125;, &#123;data : "Email"&#125;, &#123;data : "DepartmentId"&#125;, &#123;data : "UserId"&#125;, &#123;data : "WorkGroupId"&#125;, &#123;data : "IsManager"&#125;, &#123;data : "Mobile"&#125;, &#123; data : "CreateDate", &#125;, &#123; render(data, type, full, meta) &#123; return ` &lt;div class="am-btn-toolbar"&gt; &lt;div class="am-btn-group am-btn-group-xs"&gt; &lt;button class="am-btn am-btn-bg-white am-btn-xs am-text-secondary edit"&gt;&lt;span class="am-icon-pencil-square-o"&gt;&lt;/span&gt;编辑&lt;/button&gt; &lt;button class="am-btn am-btn-bg-white am-btn-xs am-text-danger am-hide-sm-only del"&gt;&lt;span class="am-icon-copy"&gt;&lt;/span&gt; 删除&lt;/button&gt; &lt;button class="am-btn am-btn-bg-white am-btn-xs am-text-warning am-hide-sm-only authorize"&gt;&lt;span class="am-icon-trash-o"&gt;&lt;/span&gt; 授权&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;` &#125; &#125;] 12param.pageSize = data.length; //页面显示记录条数，在页面显示每页显示多少项的时候param.pageIndex = data.start + 1; //开始的记录序号 pageSize：为后台数据，每页有多少条数据 pageIndex：页面索引 因为data.start默认值为0，所以加一表示第一页开始 记录自己踩过的坑]]></content>
      <categories>
        <category>JavaScript</category>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery插件开发--Tab]]></title>
    <url>%2Fjquery-plugin-tab.html</url>
    <content type="text"><![CDATA[打造自己的插件库 人工参数配置12345678$(function() &#123; $('.jq-tab').tabPlugin(&#123; //人工参数 type: 'click', effect: 'dd', auto: 1000 &#125;)&#125;) 默认参数12345this.default = &#123; type: 'click', effect: 'default', auto: false&#125; tab插件，包含三个参数可配置：触发方式，效果，是否自动播放12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function() &#123; $('.jq-tab').tabPlugin(&#123; //人工参数 type: 'click', effect: 'dd', auto: 1000 &#125;) &#125;) ;(function($, window, document) &#123; function Tab(opts) &#123; //默认参数 this.default = &#123; type: 'click', effect: 'default', auto: false &#125; //合并参数 this.opt = $.extend(true, &#123;&#125;, this.default, opts); this.lis = $('.nav').find('li'); this.content = $('.content').find('li'); this.num = 0; &#125; Tab.prototype = &#123; init() &#123; this.clickTab(); this.autoPlay(); &#125;, clickTab() &#123; var $this = this; if(this.opt.type == 'mouseover') &#123; this.lis.on(this.opt.type, function() &#123; $this.tabType($(this)); $this.tabEffect($(this).index()); &#125;) &#125; else &#123; this.lis.on('click', function() &#123; $this.tabType($(this)); $this.tabEffect($(this).index()); &#125;) &#125; &#125;, tabType(cur) &#123; var onIndex = cur.index(); cur.addClass('on').siblings().removeClass('on'); this.num = onIndex; &#125;, tabEffect(ind) &#123; if(this.opt.effect == 'fade') &#123; this.content.eq(ind).fadeIn().siblings().fadeOut(); &#125; else &#123; this.content.eq(ind).addClass('active').siblings().removeClass('active'); &#125; &#125;, //自动播放 autoPlay() &#123; var $this = this; var lis = this.lis; //防止刚开始在第一个停留2s的问题 this.num = 1; //部位false的情况下 if(this.opt.auto) &#123; setInterval(function() &#123; if($this.num &gt;= lis.length) &#123; $this.num = 0; &#125; $this.tabType(lis.eq($this.num)); $this.tabEffect($this.num); $this.num++; &#125;,this.opt.auto) &#125; &#125; &#125; $.fn.tabPlugin = function(options) &#123; //创建实例 var tab = new Tab(options); return tab.init(); &#125; &#125;)(jQuery, window, document) &lt;/script&gt;]]></content>
      <categories>
        <category>jQuery</category>
        <category>插件开发</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode设置php.validate.executablePath]]></title>
    <url>%2Fvscode-setting.html</url>
    <content type="text"><![CDATA[问题： 做php开发时提示：无法使用PHP可执行的设置，设置php.validate。executablePath配置PHP可执行文件 解决：一：打开vscode设置，找到php.validate.executablePath 二：找到php.exe路径，将php.validate.executablePath值设置成该路径即可]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpMyAdmin中导出的sql文件导入到navicat中所需注意点]]></title>
    <url>%2Fmysql-navicat.html</url>
    <content type="text"><![CDATA[好吧，这是最近在做php时碰到的问题，记录一下 这是从phpMyAdmin中导出的sql文件格式：123456CREATE TABLE IF NOT EXISTS `article` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(150) NOT NULL, `addtime` int(10) NOT NULL, PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=96 ; 这是从navicat中导出的sql文件格式：12345678910DROP TABLE IF EXISTS `chat`;CREATE TABLE `chat` ( `userid` int(10) unsigned NOT NULL AUTO_INCREMENT, `nickname` varchar(20) NOT NULL, `username` varchar(10) NOT NULL, `password` varchar(32) NOT NULL, `profile` varchar(100) NOT NULL, `systime` int(10) NOT NULL, PRIMARY KEY (`userid`)) ENGINE=MyISAM AUTO_INCREMENT=87 DEFAULT CHARSET=utf8; 既然把sql文件导入到navicat中，就肯定是按照navicat的sql文件格式来书写：1234567DROP TABLE IF EXISTS article;CREATE TABLE article ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(150) NOT NULL, `addtime` int(10) NOT NULL, PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=96 ; 注意：导入sql文件，表名是不需要带反引号的，要去掉]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode自定义代码段]]></title>
    <url>%2Fvscode-snippets.html</url>
    <content type="text"><![CDATA[提高开发效率，这些你必须要会 注意：创建哪种语言的代码片段就进相应语言的代码片段区域，写js代码段就不要把代码段写在了php的代码段编写区 JavaScript代码段123456789&#123; "Print to vue": &#123; "prefix":"vue", "body": [ "new Vue(&#123;\r\n\tel:'#app',\r\n\tdata:&#123;\r\n\t\t$2\r\n\t&#125;,\r\n&#125;)", ], "description":"script中的vue" &#125;, &#125; 效果： vue代码段123456789&#123; "Print to vue": &#123; "prefix": "vue", "body": [ "&lt;template&gt;\r\n\t$1\r\n&lt;/template&gt;\r\n\r\n&lt;script&gt;\r\n\texport default &#123;\r\n\t\tdata() &#123;\r\n\t\t\treturn &#123;\r\n\t\t\t\t\r\n\t\t\t&#125;\r\n\t\t&#125;,\r\n\t&#125;\r\n&lt;/script&gt;\r\n\r\n&lt;style scoped&gt;\r\n\t$3\r\n&lt;/style&gt;" ], "description": "vue文件的初始代码段" &#125;, &#125; 效果： 还有一种更为直观的写法，更容易书写： 双引号需要在前面加上 \ 进行转义 123456789101112"Print to js": &#123; "prefix": "js", "body": [ "&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;", "&lt;script&gt;", "\t$(function() &#123;", "\t\t$1", "\t&#125;)", "&lt;/script&gt;" ], "description": "Log output to js" &#125;, 12345678910111213141516"Print to jsvue": &#123; "prefix": "jsvue", "body": [ "&lt;div id=\"app\"&gt;&lt;/div&gt;", "&lt;script src=\"https://cdn.bootcss.com/vue/2.5.16/vue.min.js\"&gt;&lt;/script&gt;", "&lt;script&gt;", "\tnew Vue(&#123;", "\t\tel: 'app',", "\t\tdata: &#123;", "\t\t\t$1", "\t\t&#125;", "\t&#125;)", "&lt;/script&gt;" ], "description": "Log output to jsvue" &#125;,]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断一个变量是数组还是对象]]></title>
    <url>%2Farray-or-object.html</url>
    <content type="text"><![CDATA[Js中如何准确判断一个变量是什么，面试中这是考一个人基本功扎不扎实必定会问的一个问题 一，判断方法1.typeof 我们能够使用typeof判断变量的身份，判断字符串得到string，数字和NaN得到number，函数会得到function等，但是判断数组，对象和null时都会得到object，详细请看js数据类型，这就是typeof的局限性，并不能准确的判断该变量的”真实身份”。那如何判断一个变量是数组还是对象？ 2.instanceof 使用instanceof可以用来判断一个变量是数组还是对象，原理如下： 数组也是对象的一种，使用instanceof都会返回true1var arr = new Array(); 12345678910var arr = ['aa','bb','cc']; var obj = &#123; a: 'aa', b: 'bb', c: 'cc' &#125;; console.log(arr instanceof Array); //true console.log(arr instanceof Object); //true console.log(obj instanceof Array); //false console.log(obj instanceof Object); //true 明确说一下instanceof是如何判断的： instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，意思就是该变量通过原型链上能否找到构造函数的prototype 属性，还不清楚原型链的请看原型链 所以就能明白为什么instanceof判断一个变量可以分清楚它到底是数组还是对象：12Array.prototype === arr.__proto__ Object.prototype === arr.__proto__.__proto__ 因为arr的原型链上存在Array.prototype和Object.prototype只有Array类型的变量才会满足arr instanceof Array和arr instanceof Object都返回true，也只有Object类型变量才满足obj instanceof Array返回false，obj instanceof Object返回true 3.constructor123456789var arr = ['aa','bb','cc']; var obj = &#123; 'a': 'aa', 'b': 'bb', 'c': 'cc' &#125;; console.log(arr.constructor === Array); //true console.log(arr.constructor === Object); //false console.log(obj.constructor === Object); //true 4.Object.prototype.toString.call() Object.prototype.toString.call()方法可以精准判断变量类型，它返回[object constructorName]的字符串格式，这里的constructorName就是call参数的函数名12345678910111213141516171819202122232425262728var a = NaN; var b= '222'; var c = null; var d = false; var e = undefined; var f = Symbol(); var arr = ['aa','bb','cc']; var obj = &#123; 'a': 'aa', 'b': 'bb', 'c': 'cc' &#125;; var res = Object.prototype.toString.call(arr); console.log(res); //[object Array] var res2 = Object.prototype.toString.call(obj); console.log(res2); //[object Object] var res3 = Object.prototype.toString.call(a); console.log(res3); //[object Number] var res4 = Object.prototype.toString.call(b); console.log(res4); //[object String] var res4 = Object.prototype.toString.call(c); console.log(res4); //[object Null] var res5 = Object.prototype.toString.call(d); console.log(res5); //[object Boolean] var res6 = Object.prototype.toString.call(e); console.log(res6); //[object Undefined] var res7 = Object.prototype.toString.call(f); console.log(res7); //[object Symbol] 二，总结判断简单数据类型可以用typeof，判断数组，对象使用instanceof，constructor和 Object.prototype.toString.call()，最好使用Object.prototype.toString.call()，更加精准]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js内置对象Array常用方法]]></title>
    <url>%2FjsArray-ways.html</url>
    <content type="text"><![CDATA[你一定在面试中遇到过，别说没有 一，会改变原数组1. 移除数组末尾最后一项.pop()，返回删除的元素 如果你在一个空数组上调用 pop()，它返回 undefined 1234567let word = ['a', 'b', 'c', 'd']; let newArr = word.pop(); console.log(word); //['a', 'b', 'c'] console.log(newArr); //d let nullArr = []; console.log(nullArr.pop()); //undefined 2. 在数组末尾添加一个或多个元素.push()，返回修改后数组长度1234let word = ['a', 'b', 'c', 'd']; let newArr = word.push('e','f'); console.log(word); //['a', 'b', 'c', 'd', 'e', 'f'] console.log(newArr); //6 3. 移除数组第一项.shift()，返回移除的元素1234let word = ['a', 'b', 'c', 'd']; let newArr = word.shift(); console.log(word); //['b', 'c', 'd'] console.log(newArr); //a 4. 在数组头部添加一个或多个元素.unshift()，返回修改后数组长度1234let word = ['a', 'b', 'c', 'd']; let newArr = word.unshift('11','22'); console.log(word); //['11', '22', 'a', 'b', 'c', 'd'] console.log(newArr); //6 5. 对数组元素排序.sort()，返回排序后的数组 默认排序顺序是根据字符串Unicode码点 1234567891011121314151617181920212223242526let fruit = ['cherries', 'apples', 'bananas']; console.log(fruit.sort()); // ['apples', 'bananas', 'cherries'] let scores = [1, 10, 21, 2]; console.log(scores.sort()); // [1, 10, 2, 21] // 注意10在2之前, // 因为在 Unicode 指针顺序中"10"在"2"之前 let things = ['word', 'Word', '1 Word', '2 Words']; console.log(things.sort()); // ['1 Word', '2 Words', 'Word', 'word'] // 在Unicode中, 数字在大写字母之前, // 大写字母在小写字母之前. function compare(a, b) &#123; if(a &lt; b) &#123; return -1; &#125;else if(a &gt; b) &#123; return 1; &#125;else &#123; return 0; &#125; &#125; let num = [1, 10, 21, 2]; console.log(num.sort(compare)); //[1, 2, 10, 21] 6. 颠倒数组元素.reverse()，返回颠倒后的数组1234let word = ["a", "b", "c", "d"]; let newArr = word.reverse(); console.log(word); //["d", "c", "b", "a"] console.log(newArr); //["d", "c", "b", "a"] 7. 删除或插入元素.splice()，返回数组删除的项，没有删除的项，返回空数组123456789101112131415var word = ['a', 'b', 'c', 'd']; //删除,前闭后开 var newArr = word.splice(0,2); console.log(word); //["c", "d"] console.log(newArr); //["a", "b"] //插入,当前数组索引1处插入hello var newArr = word.splice(1,0,'hello'); console.log(word); //["c", "hello", "d"] console.log(newArr); //[] //替换 var newArr = word.splice(1,1,'world'); console.log(word); //["c", "world", "d"] console.log(newArr); //["hello"] 二，不会改变原数组1. 合并两个或多个数组.concat()，返回新数组12345let word = ['a', 'b', 'c', 'd']; let word2 = ['hello','world']; let newArr = word.concat(word2); console.log(word); //["a", "b", "c", "d"] console.log(newArr); //["a", "b", "c", "d", "hello", "world"] 2. 将数组所有元素连接成一个字符串.join()，返回连接后的字符串1234let word = ['a', 'b', 'c', 'd']; let newArr = word.join('---'); console.log(word); //["a", "b", "c", "d"] console.log(newArr); //a---b---c---d 3. 截取数组元素到新数组中.slice()，返回新数组123456789101112131415let word = ['a', 'b', 'c', 'd']; //原数组索引为1开始截取后面所有元素 let newArr = word.slice(1); console.log(word); //["a", "b", "c", "d"] console.log(newArr); //["b", "c", "d"] //截取原数组索引为1到3之间的元素，前闭后开 let newArr2 = word.slice(1,3); console.log(word); //["a", "b", "c", "d"] console.log(newArr2); //["b", "c"] //截取原数组倒数第三个元素与倒数第一个元素之间的元素，前闭后开 let newArr3 = word.slice(-3,-1); console.log(word); //["a", "b", "c", "d"] console.log(newArr3); //[["b", "c"] 4. 获取查询元素第一次出现的索引.indexOf()，找不到查询元素，则返回-112345let word = ['a', 'b', 'b', 'c', 'd']; let index = word.indexOf('b'); //1,第一次出现b的索引值 let index2 = word.indexOf('hello'); //-1 console.log(index); console.log(index2); 5. 获取查询元素最后一次出现的索引.lastIndexOf()，找不到查询元素，则返回-112345let word = ['a', 'b', 'b', 'c', 'd']; let index = word.lastIndexOf('b'); //2,最后一个b的索引值为2 let index2 = word.lastIndexOf('hello'); //-1 console.log(index); console.log(index2); 6. toString()返回有数组每个元素的字符串形式拼接而成的以逗号分隔的字符串123let word = ['a', 'b', 'b', 'c', 'd']; let str = word.toString(); //a,b,b,c,d console.log(str); 7. toLocaleString()返回一个字符串表示数组中的元素 更多了解查看MDN 三，迭代方法 每个方法接受含有三个参数的函数，三个参数为：数组中的项，元素索引，数组本身 every()，数组所有元素都满足要求则返回true，否则返回false some()，只要有满足要求的就返回true filter()，返回过滤后的结果数组 map()，返回在函数中处理过的数组 forEach()，遍历整个数组123456789101112131415161718192021222324var number = [1,2,3,4,5,6,7,8]; var res = number.every(function(item, index, array) &#123; return (item &gt; 2); &#125;) console.log(res); //false var res = number.some(function(item, index, array) &#123; return (item &gt; 2); &#125;) console.log(res); //true var res = number.filter(function(item, index, array) &#123; return (item &gt; 2); &#125;) console.log(res); //[3, 4, 5, 6, 7, 8] var res = number.map(function(item, index, array) &#123; return (item * 2); &#125;) console.log(res); //[2, 4, 6, 8, 10, 12, 14, 16] var res = number.forEach(function(item, index, array) &#123; //执行某些操作 &#125;) 四，归并方法迭代数组所有项，构建最终返回值，每个方法接受两个参数：调用的函数和作为归并基础的初始值。函数接受4个参数：前一个值，当前值，项索引，数组本身。函数返回的值都会作为第一个参数自动传给下一项，第一次迭代从数组第二项开始，当前值为数组第二项。 reduce()，从数组第一项开始遍历到最后 reduceRight()，从数组最后一项开始遍历到第一项12345678910111213141516 /* 开始执行回调函数cur为2，prev为1， 第二次执行回调函数，在之前的基础上加1 函数返回的值都会作为一个参数传给下一项， 最后执行函数时就是28+8 */ var number = [1,2,3,4,5,6,7,8]; var res = number.reduce(function(prev, cur, index, array) &#123; return prev + cur; &#125;) console.log(res); //1+2+3+4+5+6+7+8=36 var res = number.reduceRight(function(prev, cur, index, array) &#123; return prev + cur; &#125;) console.log(res); //8+7+6+5+4+3+2+1=36]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经验总结之JavaScript篇(一)]]></title>
    <url>%2Fjavascript-report-1.html</url>
    <content type="text"><![CDATA[此文主旨是记录面试中遇到的面试题，包括js中常见，易错，重要知识点 window.onload和$(document).ready()的区别window.onload是在页面中包含图片在内的所有元素全部加载完成再执行； $(document).ready()是DOM树加载完成之后执行，不包含图片，其他媒体文件； 因此$(document).ready()快于window.onload执行； 数组去重1const arr = ['a','bb','22','a','yuci','haha','22']; 1.es6数据结构Set 12let unique = new Set(arr); console.log(Array.from(unique)); 2.使用push() 1234567let arr2 = []; for(let i = 0; i &lt; arr.length; i++) &#123; if(arr2.indexOf(arr[i]) == -1) &#123; //不包含某个值则返回-1 arr2.push(arr[i]); &#125; &#125; console.log(arr2); 12345678//如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组 let arr3 = [arr[0]]; for(let i = 1; i &lt; arr.length; i++) &#123; if(arr.indexOf(arr[i]) == i) &#123; arr3.push(arr[i]); &#125; &#125; console.log(arr3); 3.排序去除相邻重复元素 12345678let arrSort = arr.sort(); let arr4 = []; for(let i = 0; i&lt; arrSort.length; i++) &#123; if(arrSort[i] != arrSort[i+1]) &#123; arr4.push(arrSort[i]); &#125; &#125; console.log(arr4); 4.使用splice() 1234567891011let len = arr.length; for(let i = 0; i &lt; len; i++) &#123; for(let j = i + 1; j &lt; len; j++) &#123; if(arr[i] === arr[j]) &#123; arr.splice(i,1); len--; j--; &#125; &#125; &#125; console.log(arr); 事件委托得益于事件冒泡，当多个元素有相同的事件，将事件绑定在父元素 12345678var oUl = document.getElementById('oul'); oUl.addEventListener('click', function(e) &#123; var e = e||window.event; var tar = e.target; if(tar.nodeName === 'LI') &#123; alert(tar.innerHTML); &#125; &#125;) 更详细请看：事件委托 判断变量类型 typeof()用于判断简单数据； 判断一个变量是对象还是数组使用instanceof，constructor或`Object.prototype.toString.call()； 更详细请看：判断数据类型 同步和异步（简要阐述） 同步：由于js单线程，同步任务都在主线程上排队执行，前面任务没执行完成，后面的任务会一直等待； 异步：不进入主线程，进入任务队列，等待主线程任务执行完成，开始执行。最基础的异步操作setTimeout和setInterval，等待主线程任务执行完，在开始执行里面的函数； 更详细请看：js运行机制 返回false的几种情况false，null，0，””，undefined，NaN js类型值的区别存储地： 简单数据类型：存储在栈中； 引用数据类型：存储在堆中，在栈中存储了指针，指向存储在堆中的地址，解释器会先检索在栈中的地址，从堆中获得实体； 大小： 简单数据类型：大小固定，占用空间小，频繁使用，所以存储在栈中； 引用数据类型：大小不固定，占用空间大； 闭包何为闭包：有权访问另一个作用域中变量的函数 闭包特性：可实现函数外访问函数内变量，外层变量可以不被垃圾回收机制回收 为什么？怎么解决？ 12345for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000); &#125; 输出结果都为10，因为for()循环过程中每次传值，匿名函数并没有执行，相当于执行10次function(){console.log(i);}，循环结束i变为10，所以输出全部为10； 使用闭包，自执行匿名函数包裹: 1234567for(var i = 0; i &lt; 10; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(j); &#125;, 1000); &#125;)(i); &#125; 外部匿名函数立即执行，把 i 作为参数，赋值给 j ，因为是立即执行，所以每次循环输出不同值。 引用外层变量不被回收，会相比其他函数占用更高内存，使用不当容易造成内存泄漏。 this的指向 全局范围：指向window（严格模式下不存在全局变量，指向undefined）; 普通函数调用：指向window; 对象方法调用：指向最后调用它的对象； 构造函数调用：指向new出来的对象； 显示设置this：call，apply方法显示将this指向第一个参数指明的对象 new具体做了些什么 创建一个新对象foo； 并将它的__proto__指向其构造函数的prototype，foo.__proto__ = Foo.prototype; 动态将this指向新对象，Foo.apply(foo，arguments); 执行函数体中的代码； 放回新对象foo; 原型和原型链创建一个函数就会为其创建一个prototype属性，指向这个函数的原型对象，原型对象会自动获得constructor属性，指向prototype属性所在函数。 12345678Function.prototype.a = "a"; Object.prototype.b = "b"; function Person()&#123;&#125; console.log(Person); //function Person() let p = new Person(); console.log(p); //Person &#123;&#125; 对象 console.log(p.a); //undefined console.log(p.b); //b 1p.__proto__ === Person.prototype；Person.prototype.constructor === Person 当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的__proto__属性中调用查找，也就是它构造函数的prototype中调用查找，如果构造函数中也没有该属性方法，则会去构造函数的隐式原型中查找，一直到null，就这样形成原型链。 更多有关原型请看：原型和原型链 继承方式原型链继承： Child()的原型作为Parent()的实例来继承Parent()的方法属性 因为所有实例都继承原型方法属性，其中一个实例对原型属性值更改后，所有实例调用该属性的值全部更改 12345678910111213function Parent() &#123;&#125; Parent.prototype.parentSay = function() &#123; return 'i am parent'; &#125; function Child() &#123;&#125; Child.prototype.childSay = function() &#123; return 'i am child'; &#125; Child.prototype = new Parent(); var par = new Parent(); var kid = new Child(); console.log(kid.parentSay()); //i am parent 构造函数继承： 在子类的构造函数内部通过call或apply来调用父类构造函数 无法实现函数的复用 123456789101112function People() &#123; this.name = ['zhangsan','lisi','wangwu']; &#125; function Person() &#123; People.call(this); &#125; var per1 = new Person(); per1.name.push('zhanliu'); console.log(per1.name); //["zhangsan", "lisi", "wangwu", "zhanliu"] var per2 = new Person(); console.log(per2.name); //["zhangsan", "lisi", "wangwu"] 组合继承： 将原型链继承和构造函数继承结合，最常用的继承模式 原型链继承共享的属性和方法，构造函数继承实例属性 12345678910111213141516171819202122function People(num) &#123; this.num = num; this.name = ['zhangsan','lisi','wangwu']; &#125; People.prototype.numCount = function() &#123; console.log(this.num); &#125; function Person(num) &#123; People.call(this, num); &#125; //继承方式 Person.prototype = new People(); Person.prototype.constructor = Person; var per1 = new Person(10); per1.name.push('zhaoliu'); console.log(per1.name); //["zhangsan", "lisi", "wangwu", "zhanliu"] per1.numCount(); //10 var per2 = new Person(20); console.log(per2.name); //["zhangsan", "lisi", "wangwu"] per2.numCount(); //20 更多继承方式请看：继承方式 数组常用方法改变原数组： 尾部删除pop() 尾部添加push() 头部删除shift() 头部添加unshift() 排序sort() 颠倒数组元素reverse() 删除或插入元素splice(); 不会改变元素组： 合并数组concat() 拼接数组元素join() 截取元素slice() indexOf() lastIndexOf() toString() 更详细数组方法总结请看：Array数组方法总结 数据存储Cookie：用于客户端与服务端通信，也具有本地存储的功能 localStorage，sessionStorage：专门用于存储 区别： 大小：Cookie容量为4K，因为用于客户端与服务端通信，所有http都携带，如果太大会降低效率； localStorage，sessionStorage大小为5M。 失效时间：Cookie会在浏览器关闭时删除，除非主动设置删除时间；localStorage一直都在直到用户主动删除或清除浏览器缓存；sessionStorage在浏览器关闭时删除。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入javascript之执行上下文]]></title>
    <url>%2Fjavascript-context.html</url>
    <content type="text"><![CDATA[一，相关概念 EC : 执行上下文 ECS : 执行环境栈 VO ： 变量对象 AO ： 活动对象 scope chain ：作用域链 二，执行上下文 javascript运行的代码环境有三种： 全局代码：代码默认运行的环境，最先会进入到全局环境中 函数代码：在函数的局部环境中运行的代码 Eval代码：在Eval()函数中运行的代码 全局上下文是最外围的一个执行环境，web浏览器中被认为是window对象。在初始化代码时会先进入全局上下文中，每当一个函数被调用时就会为该函数创建一个执行上下文，每个函数都有自己的执行上下文。来看一段代码： 123456789101112131415function f1() &#123; var f1Context = 'f1 context'; function f2() &#123; var f2Context = 'f2 context'; function f3() &#123; var f3Context = 'f3 context'; console.log(f3Context); &#125; f3(); console.log(f2Context); &#125; f2(); console.log(f1Context); &#125; f1(); 这段代码有4个执行上下文：全局上下文和f1()，f2()，f3()属于自己的执行上下文。 全局上下文拥有f1()，f1()的上下文中有变量f1Context和f2()，f2()的上下文有变量f2Context和f3()，f3()上下文有变量f3Context。 在这我们了解下执行环境栈ECS，一段代码所有的执行上下文都会被推入栈中等待被执行，因为js是单线程，任务都为同步任务的情况下某一时间只能执行一个任务，执行一段代码首先会进入全局上下文中，并将其压入ECS中，执行f1()会为其创建执行上下文压入栈顶，f1()中有f2()，再为f2()创建f2()的执行上下文，依次，最终全局上下文被压入到栈底，f3()的执行上下文在栈顶，函数执行完后，ECS就会弹出其上下文，f3()上下文弹出后，f2()上下文来到栈顶，开始执行f2()，依次，最后ECS中只剩下全局上下文，它等到应用程序退出，例如浏览器关闭时销毁。 总结：（执行上下文就用EC替代） 1. 全局上下文压入栈顶 2. 执行某一函数就为其创建一个EC，并压入栈顶 3. 栈顶的函数执行完之后它的EC就会从ECS中弹出，并且变量对象(VO)随之销毁 4. 所有函数执行完之后ECS中只剩下全局上下文，在应用关闭时销毁 大家再看一道道题：12345678function foo(i) &#123; if(i == 3) &#123; return; &#125; foo(i+1); console.log(i); &#125; foo(0); 大家明白执行上下文的进栈出栈就应该知道结果为什么是2，1，0 ECS栈顶为foo(3)的的上下文，直接return弹出后，栈顶变成foo(2)的上下文，执行foo(2)，输出2并弹出，执行foo(1)，输出1并弹出，执行foo(0)，输出0并弹出，关闭浏览器后全局EC弹出，所以结果为2，1，0 刚才提到VO，我们来了解什么是VO 三，VO/AOVO(变量对象) 创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。 AO(活动对象) 进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问到，可以理解为被激活 谈到了上下文的创建和执行，我们来看看EC建立的过程： 建立阶段：(函数被调用，但是还未执行函数中的代码) 1. 创建变量，参数，函数，arguments对象 2. 建立作用域链 3. 确定this的值 执行阶段：变量赋值，函数引用，执行代码 执行上下文为一个对象，包含VO，作用域链和this 12345executionContextObj = &#123; variableObject: &#123; /* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */ &#125;, scopeChain: &#123; /* variableObject 以及所有父执行上下文中的variableObject */ &#125;, this: &#123;&#125; &#125; 具体过程： 1. 找到当前上下文调用函数的代码 2. 执行代码之前，先创建执行上下文 3. 创建阶段： 3-1. 创建变量对象(VO)： 1. 创建arguments对象，检查当前上下文的参数，建立该对象下的属性和属性值 2. 扫描上下文的函数申明： 1. 每扫描到一个函数什么就会在VO里面用函数名创建一个属性，为一个指针，指向该函数在内存中的地址 2. 如果函数名在VO中已经存在，对应的属性值会被新的引用覆盖 3. 扫描上下文的变量申明： 1. 每扫描到一个变量就会用变量名作为属性名，其值初始化为undefined 2. 如果该变量名在VO中已经存在，则直接跳过继续扫描 3-2. 初始化作用域链 3-3. 确定上下文中this的指向 4. 代码执行阶段 4-1. 执行函数体中的代码，给VO中的变量赋值 看代码理解： 123456function foo(i) &#123; var a = 'hello'; var b = function privateB() &#123;&#125;; function c() &#123;&#125; &#125; foo(22); 调用foo(22)时创建上下文包括VO，作用域链，this值 以函数名作为属性值，指向该函数在内存中的地址；变量名作为属性名，其初始化值为undefined 注意：函数申明先于变量申明 1234567891011121314fooExecutionContext = &#123; variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c(), a: undefined, b: undefined &#125;, scopeChain: &#123; ... &#125;, this: &#123; ... &#125; &#125; 创建阶段结束后就会进入代码执行阶段，给VO中的变量赋值 1234567891011121314fooExecutionContext = &#123; variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c(), a: 'hello', b: pointer to function privateB() &#125;, scopeChain: &#123; ... &#125;, this: &#123; ... &#125; &#125; 四，变量提升12345678function foo() &#123; console.log(f1); //f1() &#123;&#125; console.log(f2); //undefined var f1 = 'hosting'; var f2 = function() &#123;&#125; function f1() &#123;&#125; &#125; foo(); 调用foo()时会创建VO，初始VO中变量值等有一系列的过程，所有变量初始化值为undefined，所以console.log(f2)的值为undefined。并且函数申明先于变量申明，所以console.log(f1)的值为f1()函数而不为hosting 五，总结 调用函数时会为其创建执行上下文，并压入执行环境栈的栈顶，执行完毕弹出，执行上下文被销毁，随之VO也被销毁 EC创建阶段分创建阶段和代码执行阶段 创建阶段初始变量值为undefined，执行阶段才为变量赋值 函数申明先于变量申明]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入Js系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深入Js系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入javascript之作用域]]></title>
    <url>%2Fjavascript-scope.html</url>
    <content type="text"><![CDATA[一，作用域包括静态作用域和动态作用域，静态作用域也叫词法作用域，JavaScript采用的是静态作用域。 JavaScript中作用域是指可访问变量，对象，函数的集合，也就是调用它们能生效的代码区块。在JavaScript中没有块级作用域，只有全局作用域和函数作用域，可以模仿块级作用域，下面会讲到。 全局，函数作用域看个简单的例子12345678910111213var a = 10 function f1()&#123; var b = c = 20; console.log(a); //10 console.log(c); //20 function f2() &#123; console.log(b); //20 &#125;f2(); &#125; f1(); console.log(a); //10 console.log(c); //20 console.log(b); //error var b = c = 20 是指 var b = c; c = 20在f1函数中c没使用var声明为全局变量，b为局部变量，绑定在f1函数下，外部访问不到。 模仿块级作用域没有块级作用域，但是有if()，for()等块语句，在块语句内部定义的变量会保留在它们已经存在的作用域内，举个栗子：12345if(true) &#123; var word = 'hello'; console.log(word); //hello &#125; console.log(word); //hello f()语句存在全局作用域下，所以内部定义的变量存在于全局作用域中，无论在哪都可以访问。 123456789function add(num) &#123; if(num &gt; 10) &#123; var num = 10; console.log(num); //10 &#125; console.log(num); //10 &#125; add(11); console.log(num); //Uncaught ReferenceError: num is not defined 此时if()在add函数中，内部定义的变量存在于add函数的作用域中，只有在函数和块语句中才可以访问到，外部无法访问。 使用自执行的匿名函数包裹块语句构建块作用域，也叫私有作用域1234567function add(num) &#123; for(var i = 0; i &lt; num; i++) &#123; console.log(i); //0,1,2,3,4,5,6,7,8,9 &#125; console.log(i); //10 &#125; add(10); 将代码改为：123456789function add(num) &#123; (function () &#123; for(var i = 0; i &lt; num; i++) &#123; console.log(i); //0,1,2,3,4,5,6,7,8,9 &#125; &#125;)() console.log(i); //Uncaught ReferenceError: i is not defined &#125; add(10); 此时变量i只能在for()循环中访问到，在add函数和外部都无法访问，并且在匿名函数中定义的任何变量都会在执行结束时被销毁，所以变量i只能在for()循环中使用。 在ES6中新增了块级作用域，let const声明的变量在块语句中声明时，外部无法访问。 对作用域有明确的理解对于后面学习执行上下文会有很大帮助。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入Js系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深入Js系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入javascript之原型和原型链]]></title>
    <url>%2Fjavascript-prototype.html</url>
    <content type="text"><![CDATA[原型和原型链是js中的难点也是重点，明白了原型和原型链会让我们在后面不管是学习还是工作都会更加高效，并且原型和原型链会是面试中必不可少的话题。看完此篇文章一定会让你对原型，原型链有深刻全面的了解。 一，函数对象 所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型） 所有函数拥有prototype属性（显式原型）（仅限函数） 原型对象：拥有prototype属性的对象，在定义函数时就被创建 二，构造函数看段代码1234567891011121314151617//创建构造函数 function Word(words)&#123; this.words = words; &#125; Word.prototype = &#123; alert()&#123; alert(this.words); &#125; &#125; //创建实例 var w = new Word("hello world"); w.print = function()&#123; console.log(this.words); console.log(this); //Person对象 &#125; w.print(); //hello world w.alert(); //hello world print()方法是w实例本身具有的方法，所以w.print()打印hello world；alert()不属于w实例的方法，属于构造函数的方法，w.alert()也会打印hello world，因为实例继承构造函数的方法。 实例w的隐式原型指向它构造函数的显式原型 1w.__proto__ === Word.prototype 当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的__proto__属性中调用查找，也就是它构造函数的prototype中调用查找。所以很好理解实例继承构造函数的方法和属性： w本身没有alert()方法，所以会去Word()的显式原型中调用alert()，即实例继承构造函数的方法。 三，原型和原型链12345678Function.prototype.a = "a"; Object.prototype.b = "b"; function Person()&#123;&#125; console.log(Person); //function Person() let p = new Person(); console.log(p); //Person &#123;&#125; 对象 console.log(p.a); //undefined console.log(p.b); //b 想一想p.a打印结果为undefined，p.b结果为b p是Person()的实例，是一个Person对象，它拥有一个属性值__proto__，并且__proto__是一个对象，包含两个属性值constructor和__proto__。 12console.log(p.__proto__.constructor); //function Person()&#123;&#125; console.log(p.__proto__.__proto__); //对象&#123;&#125;，拥有很多属性值 我们会发现p.__proto__.constructor返回的结果为构造函数本身，p.__proto__.__proto__有很多参数。 我们调用constructor属性，p.__proto__.__proto__.constructor得到拥有多个参数的Object()函数，Person.prototype的隐式原型的constructor指向Object()，即Person.prototype.__proto__.constructor == Object()。 从p.__proto__.constructor返回的结果为构造函数本身得到Person.prototype.constructor == Person()所以p.__proto__.__proto__== Object.prototype 。 所以p.b打印结果为b，p没有b属性，会一直通过__proto__向上查找，最后当查找到Object.prototype时找到，最后打印出b，向上查找过程中，得到的是Object.prototype，而不是Function.prototype，找不到a属性，所以结果为undefined，这就是原型链，通过__proto__向上进行查找，最终到null结束。 12console.log(p.__proto__.__proto__.__proto__); //null console.log(Object.prototype.__proto__); //null 大家理解刚才的过程，相信下面这些应该也都明白 12345678//Function function Function()&#123;&#125; console.log(Function); //Function() console.log(Function.prototype.constructor); //Function() console.log(Function.prototype.__proto__); //Object.prototype console.log(Function.prototype.__proto__.__proto__); //NULL console.log(Function.prototype.__proto__.constructor); //Object() console.log(Function.prototype.__proto__ === Object.prototype); //true 四，总结1. 查找属性，如果本身没有，则会去__proto__中查找，也就是构造函数的显式原型中查找，如果构造函数中也没有该属性，因为构造函数也是对象，也有__proto__，那么会去它的显式原型中查找，一直到null，如果没有则返回undefined。 2. p.__proto__.constructor == function Person(){} 3. p.___proto__.__proto__== Object.prototype 4. p.___proto__.__proto__.__proto__== Object.prototype.__proto__ == null 5. 通过__proto__形成原型链而非protrotype 最后附上一张图，大家阅读完之后，看图应该可以很容易理解]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入Js系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深入Js系列</tag>
      </tags>
  </entry>
</search>
