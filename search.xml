<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[经验总结之JavaScript篇(一)]]></title>
    <url>%2Fjavascript-report-1.html</url>
    <content type="text"><![CDATA[此文主旨是记录面试中遇到的面试题，包括js中常见，易错，重要知识点 window.onload和$(document).ready()的区别window.onload是在页面中包含图片在内的所有元素全部加载完成再执行； $(document).ready()是DOM树加载完成之后执行，不包含图片，其他媒体文件； 因此$(document).ready()快于window.onload执行； 数组去重1const arr = ['a','bb','22','a','yuci','haha','22']; 1.es6数据结构Set 12let unique = new Set(arr); console.log(Array.from(unique)); 2.使用push() 1234567let arr2 = []; for(let i = 0; i &lt; arr.length; i++) &#123; if(arr2.indexOf(arr[i]) == -1) &#123; //不包含某个值则返回-1 arr2.push(arr[i]); &#125; &#125; console.log(arr2); 12345678//如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组 let arr3 = [arr[0]]; for(let i = 1; i &lt; arr.length; i++) &#123; if(arr.indexOf(arr[i]) == i) &#123; arr3.push(arr[i]); &#125; &#125; console.log(arr3); 3.排序去除相邻重复元素 12345678let arrSort = arr.sort(); let arr4 = []; for(let i = 0; i&lt; arrSort.length; i++) &#123; if(arrSort[i] != arrSort[i+1]) &#123; arr4.push(arrSort[i]); &#125; &#125; console.log(arr4); 4.使用splice() 1234567891011let len = arr.length; for(let i = 0; i &lt; len; i++) &#123; for(let j = i + 1; j &lt; len; j++) &#123; if(arr[i] === arr[j]) &#123; arr.splice(i,1); len--; j--; &#125; &#125; &#125; console.log(arr); 事件委托得益于事件冒泡，当多个元素有相同的事件，将事件绑定在父元素 12345678var oUl = document.getElementById('oul'); oUl.addEventListener('click', function(e) &#123; var e = e||window.event; var tar = e.target; if(tar.nodeName === 'LI') &#123; alert(tar.innerHTML); &#125; &#125;) 更详细请看：事件委托 判断变量类型typeof()用于判断简单数据； 判断一个变量是对象还是数组使用instanceof，constructor或Object.prototype.toString.call()； 更详细请看：判断数据类型 同步和异步（简要阐述）同步：由于js单线程，同步任务都在主线程上排队执行，前面任务没执行完成，后面的任务会一直等待； 异步：不进入主线程，进入任务队列，等待主线程任务执行完成，开始执行。最基础的异步操作setTimeout和setInterval，等待主线程任务执行完，在开始执行里面的函数； 更详细请看：js运行机制 返回false的几种情况false，null，0，””，undefined，NaN js类型值的区别存储地： 简单数据类型：存储在栈中； 引用数据类型：存储在堆中，在栈中存储了指针，指向存储在堆中的地址，解释器会先检索在栈中的地址，从堆中获得实体； 大小： 简单数据类型：大小固定，占用空间小，频繁使用，所以存储在栈中； 引用数据类型：大小不固定，占用空间大； 闭包何为闭包：有权访问另一个作用域中变量的函数 闭包特性：可实现函数外访问函数内变量，外层变量可以不被垃圾回收机制回收 为什么？怎么解决？ 12345for(var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000); &#125; 输出结果都为10，因为for()循环过程中每次传值，匿名函数并没有执行，相当于执行10次function(){console.log(i);}，循环结束i变为10，所以输出全部为10； 使用闭包，自执行匿名函数包裹: 1234567for(var i = 0; i &lt; 10; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(j); &#125;, 1000); &#125;)(i); &#125; 外部匿名函数立即执行，把 i 作为参数，赋值给 j ，因为是立即执行，所以每次循环输出不同值。 引用外层变量不被回收，会相比其他函数占用更高内存，使用不当容易造成内存泄漏。 this的指向全局范围：指向window（严格模式下不存在全局变量，指向undefined）; 普通函数调用：指向window; 对象方法调用：指向最后调用它的对象； 构造函数调用：指向new出来的对象； 显示设置this：call，apply方法显示将this指向第一个参数指明的对象 new具体做了些什么创建一个新对象foo； 并将它的__proto__指向其构造函数的prototype，foo.__proto__ = Foo.prototype; 动态将this指向新对象，Foo.apply(foo，arguments); 执行函数体中的代码； 放回新对象foo; 原型和原型链创建一个函数就会为其创建一个prototype属性，指向这个函数的原型对象，原型对象会自动获得constructor属性，指向prototype属性所在函数。 12345678Function.prototype.a = "a"; Object.prototype.b = "b"; function Person()&#123;&#125; console.log(Person); //function Person() let p = new Person(); console.log(p); //Person &#123;&#125; 对象 console.log(p.a); //undefined console.log(p.b); //b 1p.__proto__ === Person.prototype；Person.prototype.constructor === Person 当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的proto属性中调用查找，也就是它构造函数的prototype中调用查找，如果构造函数中也没有该属性方法，则会去构造函数的隐式原型中查找，一直到null，就这样形成原型链。 更多有关原型请看：原型和原型链 继承方式 原型链继承： Child()的原型作为Parent()的实例来继承Parent()的方法属性 因为所有实例都继承原型方法属性，其中一个实例对原型属性值更改后，所有实例调用该属性的值全部更改 12345678910111213function Parent() &#123;&#125; Parent.prototype.parentSay = function() &#123; return 'i am parent'; &#125; function Child() &#123;&#125; Child.prototype.childSay = function() &#123; return 'i am child'; &#125; Child.prototype = new Parent(); var par = new Parent(); var kid = new Child(); console.log(kid.parentSay()); //i am parent 构造函数继承： 在子类的构造函数内部通过call或apply来调用父类构造函数 无法实现函数的复用 123456789101112function People() &#123; this.name = ['zhangsan','lisi','wangwu']; &#125; function Person() &#123; People.call(this); &#125; var per1 = new Person(); per1.name.push('zhanliu'); console.log(per1.name); //["zhangsan", "lisi", "wangwu", "zhanliu"] var per2 = new Person(); console.log(per2.name); //["zhangsan", "lisi", "wangwu"] 组合继承： 将原型链继承和构造函数继承结合，最常用的继承模式 原型链继承共享的属性和方法，构造函数继承实例属性 12345678910111213141516171819202122function People(num) &#123; this.num = num; this.name = ['zhangsan','lisi','wangwu']; &#125; People.prototype.numCount = function() &#123; console.log(this.num); &#125; function Person(num) &#123; People.call(this, num); &#125; //继承方式 Person.prototype = new People(); Person.prototype.constructor = Person; var per1 = new Person(10); per1.name.push('zhaoliu'); console.log(per1.name); //["zhangsan", "lisi", "wangwu", "zhanliu"] per1.numCount(); //10 var per2 = new Person(20); console.log(per2.name); //["zhangsan", "lisi", "wangwu"] per2.numCount(); //20 更多继承方式请看：继承方式 数组常用方法改变原数组： 尾部删除pop()，尾部添加push()，头部删除shift()，头部添加unshift()，排序sort()，颠倒数组元素reverse()，删除或插入元素splice(); 不会改变元素组： 合并数组concat()，拼接数组元素join()，截取元素slice()，indexOf()，lastIndexOf()，toString() 更详细数组方法总结请看：Array数组方法总结 数据存储Cookie：用于客户端与服务端通信，也具有本地存储的功能 localStorage，sessionStorage：专门用于存储 区别： 大小：Cookie容量为4K，因为用于客户端与服务端通信，所有http都携带，如果太大会降低效率； localStorage，sessionStorage大小为5M。 失效时间：Cookie会在浏览器关闭时删除，除非主动设置删除时间；localStorage一直都在直到用户主动删除或清除浏览器缓存；sessionStorage在浏览器关闭时删除。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入javascript之执行上下文]]></title>
    <url>%2Fjavascript-context.html</url>
    <content type="text"><![CDATA[一，相关概念 EC : 执行上下文 ECS : 执行环境栈 VO ： 变量对象 AO ： 活动对象 scope chain ：作用域链 二，执行上下文 javascript运行的代码环境有三种： 全局代码：代码默认运行的环境，最先会进入到全局环境中 函数代码：在函数的局部环境中运行的代码 Eval代码：在Eval()函数中运行的代码 全局上下文是最外围的一个执行环境，web浏览器中被认为是window对象。在初始化代码时会先进入全局上下文中，每当一个函数被调用时就会为该函数创建一个执行上下文，每个函数都有自己的执行上下文。来看一段代码： 123456789101112131415function f1() &#123; var f1Context = 'f1 context'; function f2() &#123; var f2Context = 'f2 context'; function f3() &#123; var f3Context = 'f3 context'; console.log(f3Context); &#125; f3(); console.log(f2Context); &#125; f2(); console.log(f1Context); &#125; f1(); 这段代码有4个执行上下文：全局上下文和f1()，f2()，f3()属于自己的执行上下文。 全局上下文拥有变量f1()，f1()的上下文中有变量f1Context和f2()，f2()的上下文有变量f2Context和f3()，f3()上下文有变量f3Context。 在这我们了解下执行环境栈ECS，一段代码所有的执行上下文都会被推入栈中等待被执行，因为js是单线程，任务都为同步任务的情况下某一时间只能执行一个任务，执行一段代码首先会进入全局上下文中，并将其压入ECS中，执行f1()会为其创建执行上下文压入栈顶，f1()中有f2()，再为f2()创建f2()的执行上下文，依次，最终全局上下文被压入到栈底，f3()的执行上下文在栈顶，函数执行完后，ECS就会弹出其上下文，f3()上下文弹出后，f2()上下文来到栈顶，开始执行f2()，依次，最后ECS中只剩下全局上下文，它等到应用程序退出，例如浏览器关闭时销毁。 总结：（执行上下文就用EC替代） 1. 全局上下文压入栈顶 2. 执行某一函数就为其创建一个EC，并压入栈顶 3. 栈顶的函数执行完之后它的EC就会从ECS中弹出，并且变量对象(VO)随之销毁 4. 所有函数执行完之后ECS中只剩下全局上下文，在应用关闭时销毁 大家再看一道道题：12345678function foo(i) &#123; if(i == 3) &#123; return; &#125; foo(i+1); console.log(i); &#125; foo(0); 大家明白执行上下文的进栈出栈就应该知道结果为什么是2，1，0 ECS栈顶为foo(3)的的上下文，直接return弹出后，栈顶变成foo(2)的上下文，执行foo(2)，输出2并弹出，执行foo(1)，输出1并弹出，执行foo(0)，输出0并弹出，关闭浏览器后全局EC弹出，所以结果为2，1，0 刚才提到VO，我们来了解什么是VO 三，VO/AOVO(变量对象) 创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。 AO(活动对象) 进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问到，可以理解为被激活 谈到了上下文的创建和执行，我们来看看EC建立的过程： 建立阶段：(函数被调用，但是还未执行函数中的代码) 1. 创建变量，参数，函数，arguments对象 2. 建立作用域链 3. 确定this的值 执行阶段：变量赋值，函数引用，执行代码 执行上下文为一个对象，包含VO，作用域链和this 12345executionContextObj = &#123; variableObject: &#123; /* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */ &#125;, scopeChain: &#123; /* variableObject 以及所有父执行上下文中的variableObject */ &#125;, this: &#123;&#125; &#125; 具体过程： 1. 找到当前上下文调用函数的代码 2. 执行代码之前，先创建执行上下文 3. 创建阶段： 3-1. 创建变量对象(VO)： 1. 创建arguments对象，检查当前上下文的参数，建立该对象下的属性和属性值 2. 扫描上下文的函数申明： 1. 每扫描到一个函数什么就会在VO里面用函数名创建一个属性，为一个指针，指向该函数在内存中的地址 2. 如果函数名在VO中已经存在，对应的属性值会被新的引用覆盖 3. 扫描上下文的变量申明： 1. 每扫描到一个变量就会用变量名作为属性名，其值初始化为undefined 2. 如果该变量名在VO中已经存在，则直接跳过继续扫描 3-2. 初始化作用域链 3-3. 确定上下文中this的指向 4. 代码执行阶段 4-1. 执行函数体中的代码，给VO中的变量赋值 看代码理解： 123456function foo(i) &#123; var a = 'hello'; var b = function privateB() &#123;&#125;; function c() &#123;&#125; &#125; foo(22); 调用foo(22)时创建上下文包括VO，作用域链，this值 以函数名作为属性值，指向该函数在内存中的地址；变量名作为属性名，其初始化值为undefined 注意：函数申明先于变量申明 1234567891011121314fooExecutionContext = &#123; variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c(), a: undefined, b: undefined &#125;, scopeChain: &#123; ... &#125;, this: &#123; ... &#125; &#125; 创建阶段结束后就会进入代码执行阶段，给VO中的变量赋值 1234567891011121314fooExecutionContext = &#123; variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c(), a: 'hello', b: pointer to function privateB() &#125;, scopeChain: &#123; ... &#125;, this: &#123; ... &#125; &#125; 四，变量提升12345678function foo() &#123; console.log(f1); //f1() &#123;&#125; console.log(f2); //undefined var f1 = 'hosting'; var f2 = function() &#123;&#125; function f1() &#123;&#125; &#125; foo(); 调用foo()时会创建VO，初始VO中变量值等有一系列的过程，所有变量初始化值为undefined，所以console.log(f2)的值为undefined。并且函数申明先于变量申明，所以console.log(f1)的值为f1()函数而不为hosting 五，总结 调用函数时会为其创建执行上下文，并压入执行环境栈的栈顶，执行完毕弹出，执行上下文被销毁，随之VO也被销毁 EC创建阶段分创建阶段和代码执行阶段 创建阶段初始变量值为undefined，执行阶段才为变量赋值 函数申明先于变量申明]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入Js系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深入Js系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入javascript之作用域]]></title>
    <url>%2Fjavascript-scope.html</url>
    <content type="text"><![CDATA[一，作用域包括静态作用域和动态作用域，静态作用域也叫词法作用域，JavaScript采用的是静态作用域。 JavaScript中作用域是指可访问变量，对象，函数的集合，也就是调用它们能生效的代码区块。在JavaScript中没有块级作用域，只有全局作用域和函数作用域，可以模仿块级作用域，下面会讲到。 全局，函数作用域看个简单的例子12345678910111213var a = 10 function f1()&#123; var b = c = 20; console.log(a); //10 console.log(c); //20 function f2() &#123; console.log(b); //20 &#125;f2(); &#125; f1(); console.log(a); //10 console.log(c); //20 console.log(b); //error var b = c = 20 是指 var b = c; c = 20在f1函数中c没使用var声明为全局变量，b为局部变量，绑定在f1函数下，外部访问不到。 模仿块级作用域没有块级作用域，但是有if()，for()等块语句，在块语句内部定义的变量会保留在它们已经存在的作用域内，举个栗子：12345if(true) &#123; var word = 'hello'; console.log(word); //hello &#125; console.log(word); //hello f()语句存在全局作用域下，所以内部定义的变量存在于全局作用域中，无论在哪都可以访问。 123456789function add(num) &#123; if(num &gt; 10) &#123; var num = 10; console.log(num); //10 &#125; console.log(num); //10 &#125; add(11); console.log(num); //Uncaught ReferenceError: num is not defined 此时if()在add函数中，内部定义的变量存在于add函数的作用域中，只有在函数和块语句中才可以访问到，外部无法访问。 使用自执行的匿名函数包裹块语句构建块作用域，也叫私有作用域1234567function add(num) &#123; for(var i = 0; i &lt; num; i++) &#123; console.log(i); //0,1,2,3,4,5,6,7,8,9 &#125; console.log(i); //10 &#125; add(10); 将代码改为：123456789function add(num) &#123; (function () &#123; for(var i = 0; i &lt; num; i++) &#123; console.log(i); //0,1,2,3,4,5,6,7,8,9 &#125; &#125;)() console.log(i); //Uncaught ReferenceError: i is not defined &#125; add(10); 此时变量i只能在for()循环中访问到，在add函数和外部都无法访问，并且在匿名函数中定义的任何变量都会在执行结束时被销毁，所以变量i只能在for()循环中使用。 在ES6中新增了块级作用域，let const声明的变量在块语句中声明时，外部无法访问。 对作用域有明确的理解对于后面学习执行上下文会有很大帮助。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入Js系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深入Js系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入javascript之原型和原型链]]></title>
    <url>%2Fjavascript-prototype.html</url>
    <content type="text"><![CDATA[原型和原型链是js中的难点也是重点，明白了原型和原型链会让我们在后面不管是学习还是工作都会更加高效，并且原型和原型链会是面试中必不可少的话题。看完此篇文章一定会让你对原型，原型链有深刻全面的了解。 一，函数对象 所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型） 所有函数拥有prototype属性（显式原型）（仅限函数） 原型对象：拥有prototype属性的对象，在定义函数时就被创建 二，构造函数看段代码1234567891011121314151617//创建构造函数 function Word(words)&#123; this.words = words; &#125; Word.prototype = &#123; alert()&#123; alert(this.words); &#125; &#125; //创建实例 var w = new Word("hello world"); w.print = function()&#123; console.log(this.words); console.log(this); //Person对象 &#125; w.print(); //hello world w.alert(); //hello world print()方法是w实例本身具有的方法，所以w.print()打印hello world；alert()不属于w实例的方法，属于构造函数的方法，w.alert()也会打印hello world，因为实例继承构造函数的方法。 实例w的隐式原型指向它构造函数的显式原型 1w.__proto__ === Word.prototype 当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的__proto__属性中调用查找，也就是它构造函数的prototype中调用查找。所以很好理解实例继承构造函数的方法和属性： w本身没有alert()方法，所以会去Word()的显式原型中调用alert()，即实例继承构造函数的方法。 三，原型和原型链12345678Function.prototype.a = "a"; Object.prototype.b = "b"; function Person()&#123;&#125; console.log(Person); //function Person() let p = new Person(); console.log(p); //Person &#123;&#125; 对象 console.log(p.a); //undefined console.log(p.b); //b 想一想p.a打印结果为undefined，p.b结果为b p是Person()的实例，是一个Person对象，它拥有一个属性值__proto__，并且__proto__是一个对象，包含两个属性值constructor和__proto__。 12console.log(p.__proto__.constructor); //function Person()&#123;&#125; console.log(p.__proto__.__proto__); //对象&#123;&#125;，拥有很多属性值 我们会发现p.__proto__.constructor返回的结果为构造函数本身，p.__proto__.__proto__有很多参数。 我们调用constructor属性，p.__proto__.__proto__.constructor得到拥有多个参数的Object()函数，Person.prototype的隐式原型的constructor指向Object()，即Person.prototype.__proto__.constructor == Object()。 从p.__proto__.constructor返回的结果为构造函数本身得到Person.prototype.constructor == Person()所以p.__proto__.__proto__== Object.prototype 。 所以p.b打印结果为b，p没有b属性，会一直通过__proto__向上查找，最后当查找到Object.prototype时找到，最后打印出b，向上查找过程中，得到的是Object.prototype，而不是Function.prototype，找不到a属性，所以结果为undefined，这就是原型链，通过__proto__向上进行查找，最终到null结束。 12console.log(p.__proto__.__proto__.__proto__); //null console.log(Object.prototype.__proto__); //null 大家理解刚才的过程，相信下面这些应该也都明白 12345678//Function function Function()&#123;&#125; console.log(Function); //Function() console.log(Function.prototype.constructor); //Function() console.log(Function.prototype.__proto__); //Object.prototype console.log(Function.prototype.__proto__.__proto__); //NULL console.log(Function.prototype.__proto__.constructor); //Object() console.log(Function.prototype.__proto__ === Object.prototype); //true 四，总结1. 查找属性，如果本身没有，则会去__proto__中查找，也就是构造函数的显式原型中查找，如果构造函数中也没有该属性，因为构造函数也是对象，也有__proto__，那么会去它的显式原型中查找，一直到null，如果没有则返回undefined。 2. p.__proto__.constructor == function Person(){} 3. p.___proto__.__proto__== Object.prototype 4. p.___proto__.__proto__.__proto__== Object.prototype.__proto__ == null 5. 通过__proto__形成原型链而非protrotype 最后附上一张图，大家阅读完之后，看图应该可以很容易理解]]></content>
      <categories>
        <category>JavaScript</category>
        <category>深入Js系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深入Js系列</tag>
      </tags>
  </entry>
</search>
