<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入javascript之执行上下文]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5JavaScript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[一，相关概念 EC : 执行上下文 ECS : 执行环境栈 VO ： 变量对象 AO ： 活动对象 scope chain ：作用域链 二，执行上下文 javascript运行的代码环境有三种： 全局代码：代码默认运行的环境，最先会进入到全局环境中 函数代码：在函数的局部环境中运行的代码 Eval代码：在Eval()函数中运行的代码 全局上下文是最外围的一个执行环境，web浏览器中被认为是window对象。在初始化代码时会先进入全局上下文中，每当一个函数被调用时就会为该函数创建一个执行上下文，每个函数都有自己的执行上下文。来看一段代码： 123456789101112131415function f1() &#123; var f1Context = 'f1 context'; function f2() &#123; var f2Context = 'f2 context'; function f3() &#123; var f3Context = 'f3 context'; console.log(f3Context); &#125; f3(); console.log(f2Context); &#125; f2(); console.log(f1Context); &#125; f1(); 这段代码有4个执行上下文：全局上下文和f1()，f2()，f3()属于自己的执行上下文。 全局上下文拥有变量f1()，f1()的上下文中有变量f1Context和f2()，f2()的上下文有变量f2Context和f3()，f3()上下文有变量f3Context。 在这我们了解下执行环境栈ECS，一段代码所有的执行上下文都会被推入栈中等待被执行，因为js是单线程，任务都为同步任务的情况下某一时间只能执行一个任务，执行一段代码首先会进入全局上下文中，并将其压入ECS中，执行f1()会为其创建执行上下文压入栈顶，f1()中有f2()，再为f2()创建f2()的执行上下文，依次，最终全局上下文被压入到栈底，f3()的执行上下文在栈顶，函数执行完后，ECS就会弹出其上下文，f3()上下文弹出后，f2()上下文来到栈顶，开始执行f2()，依次，最后ECS中只剩下全局上下文，它等到应用程序退出，例如浏览器关闭时销毁。 总结：（执行上下文就用EC替代） 1. 全局上下文压入栈顶 2. 执行某一函数就为其创建一个EC，并压入栈顶 3. 栈顶的函数执行完之后它的EC就会从ECS中弹出，并且变量对象(VO)随之销毁 4. 所有函数执行完之后ECS中只剩下全局上下文，在应用关闭时销毁 大家再看一道道题：12345678function foo(i) &#123; if(i == 3) &#123; return; &#125; foo(i+1); console.log(i); &#125; foo(0); 大家明白执行上下文的进栈出栈就应该知道结果为什么是2，1，0 ECS栈顶为foo(3)的的上下文，直接return弹出后，栈顶变成foo(2)的上下文，执行foo(2)，输出2并弹出，执行foo(1)，输出1并弹出，执行foo(0)，输出0并弹出，关闭浏览器后全局EC弹出，所以结果为2，1，0 刚才提到VO，我们来了解什么是VO 三，VO/AOVO(变量对象) 创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。 AO(活动对象) 进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问到，可以理解为被激活 谈到了上下文的创建和执行，我们来看看EC建立的过程： 建立阶段：(函数被调用，但是还未执行函数中的代码) 1. 创建变量，参数，函数，arguments对象 2. 建立作用域链 3. 确定this的值 执行阶段：变量赋值，函数引用，执行代码 执行上下文为一个对象，包含VO，作用域链和this 12345executionContextObj = &#123; variableObject: &#123; /* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */ &#125;, scopeChain: &#123; /* variableObject 以及所有父执行上下文中的variableObject */ &#125;, this: &#123;&#125; &#125; 具体过程： 1. 找到当前上下文调用函数的代码 2. 执行代码之前，先创建执行上下文 3. 创建阶段： 3-1. 创建变量对象(VO)： 1. 创建arguments对象，检查当前上下文的参数，建立该对象下的属性和属性值 2. 扫描上下文的函数申明： 1. 每扫描到一个函数什么就会在VO里面用函数名创建一个属性，为一个指针，指向该函数在内存中的地址 2. 如果函数名在VO中已经存在，对应的属性值会被新的引用覆盖 3. 扫描上下文的变量申明： 1. 每扫描到一个变量就会用变量名作为属性名，其值初始化为undefined 2. 如果该变量名在VO中已经存在，则直接跳过继续扫描 3-2. 初始化作用域链 3-3. 确定上下文中this的指向 4. 代码执行阶段 4-1. 执行函数体中的代码，给VO中的变量赋值 看代码理解： 123456function foo(i) &#123; var a = 'hello'; var b = function privateB() &#123;&#125;; function c() &#123;&#125; &#125; foo(22); 调用foo(22)时创建上下文包括VO，作用域链，this值 以函数名作为属性值，指向该函数在内存中的地址；变量名作为属性名，其初始化值为undefined 注意：函数申明先于变量申明 1234567891011121314fooExecutionContext = &#123; variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c(), a: undefined, b: undefined &#125;, scopeChain: &#123; ... &#125;, this: &#123; ... &#125; &#125; 创建阶段结束后就会进入代码执行阶段，给VO中的变量赋值 1234567891011121314fooExecutionContext = &#123; variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c(), a: 'hello', b: pointer to function privateB() &#125;, scopeChain: &#123; ... &#125;, this: &#123; ... &#125; &#125; 四，变量提升12345678function foo() &#123; console.log(f1); //f1() &#123;&#125; console.log(f2); //undefined var f1 = 'hosting'; var f2 = function() &#123;&#125; function f1() &#123;&#125; &#125; foo(); 调用foo()时会创建VO，初始VO中变量值等有一系列的过程，所有变量初始化值为undefined，所以console.log(f2)的值为undefined。并且函数申明先于变量申明，所以console.log(f1)的值为f1()函数而不为hosting 五，总结 调用函数时会为其创建执行上下文，并压入执行环境栈的栈顶，执行完毕弹出，执行上下文被销毁，随之VO也被销毁 EC创建阶段分创建阶段和代码执行阶段 创建阶段初始变量值为undefined，执行阶段才为变量赋值 函数申明先于变量申明]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入javascript之作用域]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5JavaScript%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[一，作用域包括静态作用域和动态作用域，静态作用域也叫词法作用域，JavaScript采用的是静态作用域。 JavaScript中作用域是指可访问变量，对象，函数的集合，也就是调用它们能生效的代码区块。在JavaScript中没有块级作用域，只有全局作用域和函数作用域，可以模仿块级作用域，下面会讲到。 全局，函数作用域看个简单的例子12345678910111213var a = 10 function f1()&#123; var b = c = 20; console.log(a); //10 console.log(c); //20 function f2() &#123; console.log(b); //20 &#125;f2(); &#125; f1(); console.log(a); //10 console.log(c); //20 console.log(b); //error var b = c = 20 是指 var b = c; c = 20在f1函数中c没使用var声明为全局变量，b为局部变量，绑定在f1函数下，外部访问不到。 模仿块级作用域没有块级作用域，但是有if()，for()等块语句，在块语句内部定义的变量会保留在它们已经存在的作用域内，举个栗子：12345if(true) &#123; var word = 'hello'; console.log(word); //hello &#125; console.log(word); //hello f()语句存在全局作用域下，所以内部定义的变量存在于全局作用域中，无论在哪都可以访问。 123456789function add(num) &#123; if(num &gt; 10) &#123; var num = 10; console.log(num); //10 &#125; console.log(num); //10 &#125; add(11); console.log(num); //Uncaught ReferenceError: num is not defined 此时if()在add函数中，内部定义的变量存在于add函数的作用域中，只有在函数和块语句中才可以访问到，外部无法访问。 使用自执行的匿名函数包裹块语句构建块作用域，也叫私有作用域1234567function add(num) &#123; for(var i = 0; i &lt; num; i++) &#123; console.log(i); //0,1,2,3,4,5,6,7,8,9 &#125; console.log(i); //10 &#125; add(10); 将代码改为：123456789function add(num) &#123; (function () &#123; for(var i = 0; i &lt; num; i++) &#123; console.log(i); //0,1,2,3,4,5,6,7,8,9 &#125; &#125;)() console.log(i); //Uncaught ReferenceError: i is not defined &#125; add(10); 此时变量i只能在for()循环中访问到，在add函数和外部都无法访问，并且在匿名函数中定义的任何变量都会在执行结束时被销毁，所以变量i只能在for()循环中使用。 在ES6中新增了块级作用域，let const声明的变量在块语句中声明时，外部无法访问。 对作用域有明确的理解对于后面学习执行上下文会有很大帮助。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入javascript之原型和原型链]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5javascript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型和原型链是js中的难点也是重点，明白了原型和原型链会让我们在后面不管是学习还是工作都会更加高效，并且原型和原型链会是面试中必不可少的话题。看完此篇文章一定会让你对原型，原型链有深刻全面的了解。 一，函数对象 所有引用类型（函数，数组，对象）都拥有__proto__属性（隐式原型） 所有函数拥有prototype属性（显式原型）（仅限函数） 原型对象：拥有prototype属性的对象，在定义函数时就被创建 二，构造函数看段代码1234567891011121314151617//创建构造函数 function Word(words)&#123; this.words = words; &#125; Word.prototype = &#123; alert()&#123; alert(this.words); &#125; &#125; //创建实例 var w = new Word("hello world"); w.print = function()&#123; console.log(this.words); console.log(this); //Person对象 &#125; w.print(); //hello world w.alert(); //hello world print()方法是w实例本身具有的方法，所以w.print()打印hello world；alert()不属于w实例的方法，属于构造函数的方法，w.alert()也会打印hello world，因为实例继承构造函数的方法。 实例w的隐式原型指向它构造函数的显式原型 1w.__proto__ === Word.prototype 当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的__proto__属性中调用查找，也就是它构造函数的prototype中调用查找。所以很好理解实例继承构造函数的方法和属性： w本身没有alert()方法，所以会去Word()的显式原型中调用alert()，即实例继承构造函数的方法。 三，原型和原型链12345678Function.prototype.a = "a"; Object.prototype.b = "b"; function Person()&#123;&#125; console.log(Person); //function Person() let p = new Person(); console.log(p); //Person &#123;&#125; 对象 console.log(p.a); //undefined console.log(p.b); //b 想一想p.a打印结果为undefined，p.b结果为b p是Person()的实例，是一个Person对象，它拥有一个属性值__proto__，并且__proto__是一个对象，包含两个属性值constructor和__proto__。 12console.log(p.__proto__.constructor); //function Person()&#123;&#125; console.log(p.__proto__.__proto__); //对象&#123;&#125;，拥有很多属性值 我们会发现p.__proto__.constructor返回的结果为构造函数本身，p.__proto__.__proto__有很多参数。 我们调用constructor属性，p.__proto__.__proto__.constructor得到拥有多个参数的Object()函数，Person.prototype的隐式原型的constructor指向Object()，即Person.prototype.__proto__.constructor == Object()。 从p.__proto__.constructor返回的结果为构造函数本身得到Person.prototype.constructor == Person()所以p.__proto__.__proto__== Object.prototype 。 所以p.b打印结果为b，p没有b属性，会一直通过__proto__向上查找，最后当查找到Object.prototype时找到，最后打印出b，向上查找过程中，得到的是Object.prototype，而不是Function.prototype，找不到a属性，所以结果为undefined，这就是原型链，通过__proto__向上进行查找，最终到null结束。 12console.log(p.__proto__.__proto__.__proto__); //null console.log(Object.prototype.__proto__); //null 大家理解刚才的过程，相信下面这些应该也都明白 12345678//Function function Function()&#123;&#125; console.log(Function); //Function() console.log(Function.prototype.constructor); //Function() console.log(Function.prototype.__proto__); //Object.prototype console.log(Function.prototype.__proto__.__proto__); //NULL console.log(Function.prototype.__proto__.constructor); //Object() console.log(Function.prototype.__proto__ === Object.prototype); //true 四，总结1. 查找属性，如果本身没有，则会去__proto__中查找，也就是构造函数的显式原型中查找，如果构造函数中也没有该属性，因为构造函数也是对象，也有__proto__，那么会去它的显式原型中查找，一直到null，如果没有则返回undefined。 2. p.__proto__.constructor == function Person(){} 3. p.___proto__.__proto__== Object.prototype 4. p.___proto__.__proto__.__proto__== Object.prototype.__proto__ == null 5. 通过__proto__形成原型链而非protrotype 最后附上一张图，大家阅读完之后，看图应该可以很容易理解]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
</search>
