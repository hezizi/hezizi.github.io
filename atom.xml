<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yucihent&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yucihent.top/"/>
  <updated>2018-04-20T07:32:54.895Z</updated>
  <id>http://yucihent.top/</id>
  
  <author>
    <name>Yucihent</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入javascript之作用域</title>
    <link href="http://yucihent.top/2018/04/20/%E6%B7%B1%E5%85%A5JavaScript%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yucihent.top/2018/04/20/深入JavaScript之作用域/</id>
    <published>2018-04-19T23:35:36.000Z</published>
    <updated>2018-04-20T07:32:54.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一，作用域"><a href="#一，作用域" class="headerlink" title="一，作用域"></a>一，作用域</h2><p>包括静态作用域和动态作用域，静态作用域也叫词法作用域，JavaScript采用的是静态作用域。</p><p>JavaScript中作用域是指可访问变量，对象，函数的集合，也就是调用它们能生效的代码区块。在JavaScript中没有块级作用域，只有全局作用域和函数作用域，可以模仿块级作用域，下面会讲到。</p><a id="more"></a><h3 id="全局，函数作用域"><a href="#全局，函数作用域" class="headerlink" title="全局，函数作用域"></a>全局，函数作用域</h3><p>看个简单的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> b = c = <span class="number">20</span>;  </span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">//10  </span></span><br><span class="line">    <span class="built_in">console</span>.log(c);     <span class="comment">//20  </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">       <span class="built_in">console</span>.log(b); <span class="comment">//20  </span></span><br><span class="line">    &#125;f2();  </span><br><span class="line">&#125;  </span><br><span class="line">f1();  </span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">//10  </span></span><br><span class="line"><span class="built_in">console</span>.log(c);     <span class="comment">//20  </span></span><br><span class="line"><span class="built_in">console</span>.log(b);     <span class="comment">//error</span></span><br></pre></td></tr></table></figure></p><p>var b = c = 20  是指 var b = c; c = 20<br>在f1函数中c没使用var声明为全局变量，b为局部变量，绑定在f1函数下，外部访问不到。</p><h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>没有块级作用域，但是有if()，for()等块语句，<strong>在块语句内部定义的变量会保留在它们已经存在的作用域内</strong>，举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;  </span><br><span class="line">    <span class="keyword">var</span> word = <span class="string">'hello'</span>;  </span><br><span class="line">    <span class="built_in">console</span>.log(word);  <span class="comment">//hello  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(word);      <span class="comment">//hello</span></span><br></pre></td></tr></table></figure></p><p>f()语句存在全局作用域下，所以内部定义的变量存在于全局作用域中，无论在哪都可以访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">10</span>) &#123;  </span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">10</span>;  </span><br><span class="line">        <span class="built_in">console</span>.log(num);   <span class="comment">//10  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">console</span>.log(num);       <span class="comment">//10  </span></span><br><span class="line">&#125;  </span><br><span class="line">add(<span class="number">11</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//Uncaught ReferenceError: num is not defined</span></span><br></pre></td></tr></table></figure><p>此时if()在add函数中，内部定义的变量存在于add函数的作用域中，只有在函数和块语句中才可以访问到，外部无法访问。</p><p> <strong>使用自执行的匿名函数包裹块语句构建块作用域，也叫私有作用域</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(i);     <span class="comment">//0,1,2,3,4,5,6,7,8,9  </span></span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="built_in">console</span>.log(i);        <span class="comment">//10  </span></span><br><span class="line">   &#125;  </span><br><span class="line"> add(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>将代码改为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;  </span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;  </span><br><span class="line">           <span class="built_in">console</span>.log(i);  <span class="comment">//0,1,2,3,4,5,6,7,8,9  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;)()  </span><br><span class="line">   <span class="built_in">console</span>.log(i);      <span class="comment">//Uncaught ReferenceError: i is not defined  </span></span><br><span class="line">&#125;  </span><br><span class="line">add(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><p>此时变量i只能在for()循环中访问到，在add函数和外部都无法访问，并且在匿名函数中定义的任何变量都会在执行结束时被销毁，所以变量i只能在for()循环中使用。</p><p>在ES6中新增了块级作用域，let const声明的变量在块语句中声明时，外部无法访问。</p><p>对作用域有明确的理解对于后面学习执行上下文会有很大帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一，作用域&quot;&gt;&lt;a href=&quot;#一，作用域&quot; class=&quot;headerlink&quot; title=&quot;一，作用域&quot;&gt;&lt;/a&gt;一，作用域&lt;/h2&gt;&lt;p&gt;包括静态作用域和动态作用域，静态作用域也叫词法作用域，JavaScript采用的是静态作用域。&lt;/p&gt;
&lt;p&gt;JavaScript中作用域是指可访问变量，对象，函数的集合，也就是调用它们能生效的代码区块。在JavaScript中没有块级作用域，只有全局作用域和函数作用域，可以模仿块级作用域，下面会讲到。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yucihent.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yucihent.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入javascript之原型和原型链</title>
    <link href="http://yucihent.top/2018/04/19/%E6%B7%B1%E5%85%A5javascript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yucihent.top/2018/04/19/深入javascript之原型和原型链/</id>
    <published>2018-04-19T13:22:27.000Z</published>
    <updated>2018-04-20T07:32:49.502Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/28501094/38719872-a6076836-3f26-11e8-907e-f040e8760c9b.png" alt="image"></p><p>原型和原型链是js中的难点也是重点，明白了原型和原型链会让我们在后面不管是学习还是工作都会更加高效，并且原型和原型链会是面试中必不可少的话题。看完此篇文章一定会让你对原型，原型链有深刻全面的了解。</p><a id="more"></a><h2 id="一，函数对象"><a href="#一，函数对象" class="headerlink" title="一，函数对象"></a>一，函数对象</h2><ul><li>所有引用类型（函数，数组，对象）都拥有<code>__proto__</code>属性（隐式原型）</li><li>所有函数拥有<code>prototype</code>属性（显式原型）（仅限函数）</li><li>原型对象：拥有<code>prototype</code>属性的对象，在定义函数时就被创建</li></ul><h2 id="二，构造函数"><a href="#二，构造函数" class="headerlink" title="二，构造函数"></a>二，构造函数</h2><p>看段代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建构造函数  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Word</span>(<span class="params">words</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.words = words;  </span><br><span class="line">&#125;  </span><br><span class="line">Word.prototype = &#123;  </span><br><span class="line">    alert()&#123;  </span><br><span class="line">        alert(<span class="keyword">this</span>.words);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//创建实例  </span></span><br><span class="line"><span class="keyword">var</span> w = <span class="keyword">new</span> Word(<span class="string">"hello world"</span>);  </span><br><span class="line">w.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.words);  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//Person对象  </span></span><br><span class="line">&#125;  </span><br><span class="line">w.print();  <span class="comment">//hello world  </span></span><br><span class="line">w.alert();  <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure></p><p>print()方法是w实例本身具有的方法，所以w.print()打印hello world；alert()不属于w实例的方法，属于构造函数的方法，w.alert()也会打印hello world，因为实例继承构造函数的方法。</p><p><strong>实例w的隐式原型指向它构造函数的显式原型</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.__proto__ === Word.prototype</span><br></pre></td></tr></table></figure><p><strong>当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的<code>__proto__</code>属性中调用查找，也就是它构造函数的<code>prototype</code>中调用查找</strong>。所以很好理解实例继承构造函数的方法和属性：</p><p>w本身没有alert()方法，所以会去Word()的显式原型中调用alert()，即实例继承构造函数的方法。</p><h2 id="三，原型和原型链"><a href="#三，原型和原型链" class="headerlink" title="三，原型和原型链"></a>三，原型和原型链</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.a = <span class="string">"a"</span>;  </span><br><span class="line"><span class="built_in">Object</span>.prototype.b = <span class="string">"b"</span>;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(Person);    <span class="comment">//function Person()  </span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person();  </span><br><span class="line"><span class="built_in">console</span>.log(p);         <span class="comment">//Person &#123;&#125; 对象  </span></span><br><span class="line"><span class="built_in">console</span>.log(p.a);       <span class="comment">//undefined  </span></span><br><span class="line"><span class="built_in">console</span>.log(p.b);       <span class="comment">//b</span></span><br></pre></td></tr></table></figure><p>想一想p.a打印结果为undefined，p.b结果为b</p><p>p是Person()的实例，是一个Person对象，它拥有一个属性值<code>__proto__</code>，并且<code>__proto__</code>是一个对象，包含两个属性值<code>constructor</code>和<code>__proto__</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p.__proto__.constructor);   <span class="comment">//function Person()&#123;&#125;  </span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__.__proto__);     <span class="comment">//对象&#123;&#125;，拥有很多属性值</span></span><br></pre></td></tr></table></figure><p>我们会发现<code>p.__proto__.constructor</code>返回的结果为构造函数本身，<code>p.__proto__.__proto__</code>有很多参数。</p><p><img src="https://user-images.githubusercontent.com/28501094/38719701-d997be4a-3f25-11e8-8674-00875350e6b4.png" alt="image"></p><p><strong>我们调用constructor属性，<code>p.__proto__.__proto__.constructor</code>得到拥有多个参数的Object()函数，<code>Person.prototype</code>的隐式原型的<code>constructor</code>指向Object()，即<code>Person.prototype.__proto__.constructor == Object()</code></strong>。</p><p><strong>从<code>p.__proto__.constructor</code>返回的结果为构造函数本身得到<code>Person.prototype.constructor == Person()</code>所以<code>p.__proto__.__proto__== Object.prototype</code></strong> 。</p><p> 所以p.b打印结果为b，p没有b属性，会一直通过<code>__proto__</code>向上查找，最后当查找到<code>Object.prototype</code>时找到，最后打印出b，向上查找过程中，得到的是<code>Object.prototype</code>，而不是<code>Function.prototype</code>，找不到a属性，所以结果为undefined，这就是原型链，通过<code>__proto__</code>向上进行查找，最终到null结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p.__proto__.__proto__.__proto__);   <span class="comment">//null  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);        <span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>大家理解刚才的过程，相信下面这些应该也都明白</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Function</span>(<span class="params"></span>)</span>&#123;&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>);  <span class="comment">//Function()  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.constructor);    <span class="comment">//Function()  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__);      <span class="comment">//Object.prototype  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__.__proto__);    <span class="comment">//NULL  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__.constructor);  <span class="comment">//Object()  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="四，总结"><a href="#四，总结" class="headerlink" title="四，总结"></a>四，总结</h2><pre><code>1. 查找属性，如果本身没有，则会去__proto__中查找，也就是构造函数的显式原型中查找，如果构造函数中也没有该属性，因为构造函数也是对象，也有__proto__，那么会去它的显式原型中查找，一直到null，如果没有则返回undefined。2. p.__proto__.constructor  == function Person(){}3. p.___proto__.__proto__== Object.prototype4. p.___proto__.__proto__.__proto__== Object.prototype.__proto__ == null          5. 通过__proto__形成原型链而非protrotype</code></pre><p>最后附上一张图，大家阅读完之后，看图应该可以很容易理解</p><p><img src="https://user-images.githubusercontent.com/28501094/38719872-a6076836-3f26-11e8-907e-f040e8760c9b.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/28501094/38719872-a6076836-3f26-11e8-907e-f040e8760c9b.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;原型和原型链是js中的难点也是重点，明白了原型和原型链会让我们在后面不管是学习还是工作都会更加高效，并且原型和原型链会是面试中必不可少的话题。看完此篇文章一定会让你对原型，原型链有深刻全面的了解。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yucihent.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yucihent.top/tags/JavaScript/"/>
    
      <category term="原型" scheme="http://yucihent.top/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="http://yucihent.top/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
</feed>
